#!/usr/bin/env bash
# @cmd Set up development environment (install git hooks)
# @alias s
setup() {
  echo "Setting up pre-commit config..."
  if [ ! -f .pre-commit-config.yaml ]; then
    cp .pre-commit-config.yaml.template .pre-commit-config.yaml
    echo "✓ Created .pre-commit-config.yaml from template"
  else
    echo "✓ .pre-commit-config.yaml already exists"
  fi

  echo "Installing git hooks..."
  prek install
  echo "✅ Development environment ready"
}

# @cmd Create a release zip file
# @alias r
release() {
  echo "Building Rust binary..."
  cargo build --release
  echo ""
  echo "Building release zip..."
  nix build
  echo "✅ Release ready: result/yx.zip"
}

# @cmd Build a Linux release in Docker (for testing installer on macOS)
# @alias rl
release-linux() {
  echo "Building Linux release in Docker..."

  # Create a temporary directory for the build
  local build_dir
  build_dir=$(mktemp -d)
  trap 'rm -rf "$build_dir"' EXIT

  # Create a Dockerfile for the build
  cat > "$build_dir/Dockerfile" <<'EOF'
FROM nixos/nix:latest
WORKDIR /workspace
RUN nix-channel --update
COPY . .
RUN nix --extra-experimental-features "nix-command flakes" build
CMD ["cp", "result/yx.zip", "/output/yx-linux-x86_64.zip"]
EOF

  # Copy source files
  rsync -a --exclude='.git' --exclude='result' --exclude='.yaks' \
    --exclude='node_modules' --exclude='.worktrees' \
    ./ "$build_dir/"

  # Build in Docker
  docker build -t yx-linux-builder "$build_dir" >/dev/null 2>&1 || {
    echo "Error: Docker build failed"
    return 1
  }

  # Extract the release
  mkdir -p result-linux
  docker run --rm -v "$(pwd)/result-linux:/output" yx-linux-builder

  # Clean up Docker image
  docker rmi yx-linux-builder >/dev/null 2>&1 || true

  echo "✓ Linux release built: result-linux/yx-linux-x86_64.zip"
  echo ""
  echo "To test the installer:"
  echo "  YX_SOURCE=\"$(pwd)/result-linux/yx-linux-x86_64.zip\" ./spec/features/run-installer-test.sh"
}

# @cmd Run linting (shellcheck + Rust clippy + rustfmt)
# @alias l
lint() {
  local exit_code=0

  echo "Running shellcheck..."
  # Check bin/yx explicitly (only fail on warning or error, not info)
  if ! shellcheck -S warning bin/yx; then
    exit_code=1
  fi

  # Find and check all .sh files
  while IFS= read -r -d '' file; do
    if ! shellcheck -S warning "$file"; then
      exit_code=1
    fi
  done < <(find . -name "*.sh" -print0)

  echo ""
  echo "Running Rust clippy..."
  if ! cargo clippy -- -D warnings; then
    exit_code=1
  fi

  echo ""
  echo "Running Rust format check..."
  if ! cargo fmt --check; then
    exit_code=1
  fi

  return $exit_code
}

# @cmd Run tests (shellspec)
# @alias t
test() {
  shellspec
  cargo test
}

# @cmd Run all checks (tests + lint + audit) and mark as verified
# @alias c
check() {
  echo "Running acceptance tests..."
  if ! shellspec; then
    echo "❌ Acceptance tests failed"
    return 1
  fi

  echo "Running unit tests..."
  if ! cargo test; then
    echo "❌ Unit tests failed"
    return 1
  fi

  echo ""
  echo "Running linter..."
  if ! lint; then
    echo "❌ Linting failed"
    return 1
  fi

  echo ""
  echo "Running security audit..."
  if command -v cargo-audit >/dev/null 2>&1; then
    if ! cargo audit; then
      echo "❌ Security audit failed"
      return 1
    fi
  else
    echo "⚠️  cargo-audit not installed (run: cargo install cargo-audit)"
    echo "   Skipping security audit check"
  fi

  echo ""
  touch .last-checked
  echo "✅ All checks passed - changes verified"
}

# @cmd Run Ralph Wiggum loop (iterations with pause)
# @option --max-iterations <NUM> Number of iterations to run (default: 20)
ralph() {
  local max_iterations="${argc_max_iterations:-20}"

  for ((i=1; i<=max_iterations; i++)); do
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo " Iteration $i/$max_iterations"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    echo prompt.md | claude -p --allowedTools "Read,Write,Edit"
  done
}

eval "$(argc --argc-eval "$0" "$@")"
